# ACTIVIDAD 9

## Actividad: Red-Green-Refactor

### Primera iteración (RGR 1): Agregar artículos al carrito
1. Escribir una prueba que falle (Red)

<img src="../Imagenes/act9/iter1_1.jpg" width="560">

2. Implementar el código para pasar la prueba (Green)

<img src="../Imagenes/act9/iter1_2.jpg" width="560">

3. Refactorizar el código si es necesario (Refactor)
En este caso, no es necesario.

### Segunda iteración (RGR 2): Eliminar artículos del carrito

1. Escribir una prueba que falle (Red)

<img src="../Imagenes/act9/iter2_1.jpg" width="560">

2. Implementar el código para pasar la prueba (Green)

<img src="../Imagenes/act9/iter2_2.jpg" width="560">

3. Refactorizar el código si es necesario (Refactor)

<img src="../Imagenes/act9/iter2_3.jpg" width="560">

### Tercera iteración (RGR 3): Calcular el total del carrito

1. Escribir una prueba que falle (Red)

<img src="../Imagenes/act9/iter3_1.jpg" width="560">

2. Implementar el código para pasar la prueba (Green)

<img src="../Imagenes/act9/iter3_2.jpg" width="560">

3. Refactorizar el código si es necesario (Refactor)

<img src="../Imagenes/act9/iter3_3.jpg" width="560">

### Ejecutando las pruebas

<img src="../Imagenes/act9/pytest1.jpg" width="560">

### Cuarta iteración (RGR 4): Agregar artículos al carrito

1. Escribir una prueba que falle (Red)

<img src="../Imagenes/act9/iter4_1.jpg" width="560">

2. Implementar el código para pasar la prueba (Green)

<img src="../Imagenes/act9/iter4_2.jpg" width="560">

3. Refactorizar el código si es necesario (Refactor)
En este caso, no es necesario.

### Quinta iteración (RGR 5): eliminar artículos del carrito

1. Escribir una prueba que falle (Red)

<img src="../Imagenes/act9/iter5_1.jpg" width="560">

2. Implementar el código para pasar la prueba (Green)

<img src="../Imagenes/act9/iter5_2.jpg" width="560">

3. Refactorizar el código si es necesario (Refactor)

<img src="../Imagenes/act9/iter5_3.jpg" width="560">

### Sexta iteración (RGR 6): calcular el total del carrito

1. Escribir una prueba que falle (Red)

<img src="../Imagenes/act9/iter6_1.jpg" width="560">

2. Implementar el código para pasar la prueba (Green)

<img src="../Imagenes/act9/iter6_2.jpg" width="560">

3. Refactorizar el código si es necesario (Refactor)

<img src="../Imagenes/act9/iter6_3.jpg" width="560">

### Séptima iteración (RGR 7): aplicar descuentos al total

1. Escribir una prueba que falle (Red)

<img src="../Imagenes/act9/iter7_1.jpg" width="560">

2. Implementar el código para pasar la prueba (Green)

<img src="../Imagenes/act9/iter7_2.jpg" width="560">

3. Refactorizar el código si es necesario (Refactor)

<img src="../Imagenes/act9/iter7_3.jpg" width="560">

### Ejecutando las pruebas

<img src="../Imagenes/act9/pytest2.jpg" width="560">

## RGR, mocks, stubs e inyección de dependencias

### Octava iteración (RGR 8): agregar artículos al carrito

1. Escribir una prueba que falle (Red)

<img src="../Imagenes/act9/iter8_1.jpg" width="560">

2. Implementar el código para pasar la prueba (Green)

<img src="../Imagenes/act9/iter8_2.jpg" width="560">

3. Refactorizar el código si es necesario (Refactor)
En este caso, no es necesario.

### Novena iteración (RGR 9): eliminar artículos del carrito

1. Escribir una prueba que falle (Red)

<img src="../Imagenes/act9/iter5_1.jpg" width="560">

2. Implementar el código para pasar la prueba (Green)

<img src="../Imagenes/act9/iter5_2.jpg" width="560">

3. Refactorizar el código si es necesario (Refactor)

<img src="../Imagenes/act9/iter5_3.jpg" width="560">

### Décima iteración (RGR 10): calcular el total del carrito

1. Escribir una prueba que falle (Red)

<img src="../Imagenes/act9/iter10_1.jpg" width="560">

2. Implementar el código para pasar la prueba (Green)

<img src="../Imagenes/act9/iter10_2.jpg" width="560">

3. Refactorizar el código si es necesario (Refactor)

<img src="../Imagenes/act9/iter10_3.jpg" width="560">

### Onceava iteración (RGR 11): aplicar descuentos al total

1. Escribir una prueba que falle (Red)

<img src="../Imagenes/act9/iter11_1.jpg" width="560">

2. Implementar el código para pasar la prueba (Green)

<img src="../Imagenes/act9/iter11_2.jpg" width="560">

3. Refactorizar el código si es necesario (Refactor)

Podemos mantener la implementación actual, ya que ya hemos añadido validaciones y redondeo adecuado.

### Doceava iteración (RGR 5): Procesar Pagos a través de un Servicio Externo

1. Escribir una prueba que falle (Red)

<img src="../Imagenes/act9/iter12_1.jpg" width="560">

2. Implementar el código para pasar la prueba (Green)

<img src="../Imagenes/act9/iter12_2.jpg" width="560">

3. Refactorizar el código si es necesario (Refactor)

<img src="../Imagenes/act9/iter12_3.jpg" width="560">

### Ejecutando las pruebas

<img src="../Imagenes/act9/pytest3.jpg" width="560">

## Ejercicio

### Iteración 1: Agregar usuario (Básico)

- Paso 1 (Red): Escribimos la primera prueba

<img src="../Imagenes/act9/ejer_iter1_1.jpg" width="560">

- Paso 2 (Green): Implementamos lo mínimo para que pase la prueba

<img src="../Imagenes/act9/ejer_iter1_2.jpg" width="560">

- Paso 3 (Refactor)
Revisamos que el código sea claro y conciso. Por ahora, el diseño es simple y cumple su función.

### Iteración 2: Autenticación de usuario (Introducción de una dependencia para Hashing)

- Paso 1 (Red): Escribimos la primera prueba

<img src="../Imagenes/act9/ejer_iter2_1.jpg" width="560">

- Paso 2 (Green): Implementamos la funcionalidad y la DI

<img src="../Imagenes/act9/ejer_iter2_2.jpg" width="560">

<img src="../Imagenes/act9/pytest4.jpg" width="560">

- Paso 3 (Refactor)
Podemos refactorizar si lo consideramos necesario, pero por ahora la estructura cumple el propósito.

### Iteración 3: Uso de un Mock para verificar llamadas (Spy / Mock)

- Paso 1 (Red): Escribimos la prueba de "espionaje"

<img src="../Imagenes/act9/ejer_iter3_1.jpg" width="560">

- Paso 2 (Green): Probar que todo pasa

<img src="../Imagenes/act9/pytest5.jpg" width="560">

- Paso 3 (Refactor)
No hay cambios adicionales. El uso de Mocks/Spies simplemente corrobora el comportamiento interno.

### Iteración 4: Excepción al agregar usuario existente (Stubs/más pruebas negativas)

- Paso 1 (Red): Prueba

<img src="../Imagenes/act9/ejer_iter4_1.jpg" width="560">

- Paso 2 (Green):

<img src="../Imagenes/act9/pytest6.jpg" width="560">

- Paso 3 (Refactor)
Nada adicional por el momento.

### Iteración 5: Agregar un "Fake" repositorio de datos (Inyección de Dependencias)

- Paso 1 (Red): Nueva prueba

<img src="../Imagenes/act9/ejer_iter5_1.jpg" width="560">

- Paso 2 (Green): Implementación

<img src="../Imagenes/act9/ejer_iter5_2.jpg" width="560">

<img src="../Imagenes/act9/pytest7.jpg" width="560">

- Paso 3 (Refactor)
El código quedó un poco más ordenado; `UserManager` no depende directamente de la estructura interna de almacenamiento.

### Iteración 6: Introducir un “Spy” de notificaciones (Envío de correo)

- Paso 1 (Red): Prueba

<img src="../Imagenes/act9/ejer_iter6_1.jpg" width="560">

- Paso 2 (Green): Implementamos la llamada al servicio de correo

<img src="../Imagenes/act9/ejer_iter6_2.jpg" width="560">

<img src="../Imagenes/act9/pytest8.jpg" width="560">

- Paso 3 (Refactor)
Podríamos refactorizar lo que queramos, pero la lógica principal es clara: si se inyecta `email_service`, se usa; si no, no se hace nada especial.

## Ejercicio Integral

### Iteración 1: Agregar usuario (Básico)

- Paso 1 (Red): Primera prueba

<img src="../Imagenes/act9/ejerint_iter1_1.jpg" width="560">

- Paso 2 (Green): Implementamos lo mínimo

<img src="../Imagenes/act9/ejerint_iter1_2.jpg" width="560">

<img src="../Imagenes/act9/pytest9.jpg" width="560">

- Paso 3 (Refactor)
Revisamos si el código está limpio. Por ahora está bien.

### Iteración 2: Autenticación con inyección de un servicio de Hashing (Fake)

- Paso 1 (Red): Nueva prueba

<img src="../Imagenes/act9/ejerint_iter2_1.jpg" width="560">

- Paso 2 (Green): Implementación con inyección de hash_service

<img src="../Imagenes/act9/ejerint_iter2_2.jpg" width="560">

<img src="../Imagenes/act9/pytest10.jpg" width="560">

- Paso 3 (Refactor)
El código se ve bien para esta etapa.

### Iteración 3: Uso de un Mock/Spy para verificar llamadas internas

- Paso 1 (Red): Prueba con Spy

<img src="../Imagenes/act9/ejerint_iter3_1.jpg" width="560">

- Paso 2 (Green):
Nuestra implementación ya invoca `hash(...)`, así que al correr `pytest` debería pasar sin cambios.

<img src="../Imagenes/act9/pytest11.jpg" width="560">

- Paso 3 (Refactor)
Nada que modificar

### Iteración 4: Uso de Stubs para forzar comportamientos

- Paso 1 (Red): Nueva prueba

<img src="../Imagenes/act9/ejerint_iter4_1.jpg" width="560">

- Paso 2 (Green): Implementación con inyección de hash_service

Ya tenemos en `add_user` la lógica que lanza la excepción si existe el usuario. La prueba debe pasar con normalidad

<img src="../Imagenes/act9/pytest12.jpg" width="560">

- Paso 3 (Refactor)
Sin modificaciones

### Iteración 5: Inyección de un repositorio (Fake)

- Paso 1 (Red): Prueba con un repositorio fake

<img src="../Imagenes/act9/ejerint_iter5_1.jpg" width="560">

- Paso 2 (Green): Implementación

<img src="../Imagenes/act9/ejerint_iter5_2.jpg" width="560">

<img src="../Imagenes/act9/pytest13.jpg" width="560">

- Paso 3 (Refactor)
El código se ve bien.

### Iteración 6: Spy de Servicio de Correo

- Paso 1 (Red): Prueba

<img src="../Imagenes/act9/ejerint_iter6_1.jpg" width="560">

- Paso 2 (Green): Implementación en `UserManager`

<img src="../Imagenes/act9/ejerint_iter6_2.jpg" width="560">

<img src="../Imagenes/act9/pytest14.jpg" width="560">

- Paso 3 (Refactor)
Código listo. Hemos visto el uso de un Mock/Spy para verificar interacciones.
